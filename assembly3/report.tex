\documentclass[UTF8,a4paper]{ctexart}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{color}
\usepackage{alltt}
\usepackage{marvosym}
\usepackage{xcolor}
\input {highlight.sty}
\title{计算机原理第三次实验报告}
\author{张蔚桐\ 2015011493\ 自55}
\begin {document}
\maketitle
\section{实验目的}
\begin{enumerate}
\item 练习使用子程序和宏
\item 练习使用功能调用（INT 21H）中关于字符输入及字符输出的部分
\end{enumerate}
\section{实验内容}
实验完成了所有的必做和选做任务，下面按照程序执行的流程分块解释。

程序事先存储若干字符串方便后期显示的时候调用，同时将数据存储在1000H的偏移地址上。

程序开始执行后，首先完成必要的幅值工作和初始化工作，之后在Line30开始输出字符串“INPUT 10 DECIMAL NUMBER:”提示用户输入十个十进制数，Line33时，程序将DI指针移向输入内存块NUMBERS的最后一个单元，之后进入循环输入

整个循环退出的条件是DI指针移动到NUMBERS偏移地址之前，这样完成了对NUMBERS数据区的写入操作

在循环体内执行如下操作

首先调用INT 21H中断完成一个字符的读入工作，调用模式为(AH=08H)即输入不回显，检查输入的字符，如果为0DH（回车）的话更换为空格重新输出，保证输入格式的美观性，到此完成Line44之前的工作

之后开始对输入的字符进行检查，如Line47开始，首先检查是否为ASCII码的数字，如果为数字的话所执行的语句在Line53所示，检查DH（已经输入的数字）是否超过两位，如果超过两位，跳转到OVER处理块

如果输入正常，则左移DH4位，将DL从ASCII码转换为数字，之后将DL加到DH上，完成对DH的修改

如果输入的字符不是数字，如Line48等行所示，将跳转至NOTNUM处理块

下面叙述NOTNUM处理块的行为，首先检测输入的字符是否为空格，如果输入的字符为回车，因为已经在上面所述的步骤中进行了替换，因此可以一起处理。如果此时DH非零，说明结束了一个数字的输入，进入后续的OUTPUT处理块，否则返回循环开始，重新输入，相当于连续输入多个空格（回车）是无效行为

如果输入的非数字不是空格（或回车）的话，说明输入了错误字符，如Line64所示，程序显示错误原因“NOT DECIMAL NUMBER!”并通过调用CORRECT函数，显示当前的错误信息

现在说明OVER处理块的处理形式，和上面一样，具体的实现如Line69所示，程序显示错误原因“TOO MANY DIGITS”，并通过调用CORRECT函数，显示当前的错误信息

下面说明CORRECT函数的处理方式，具体实现Line137所示，首先程序调用SHOW函数显示当前已经输入的数字，其次程序提示用户还需要输入的数字，如Line147所示，首先程序将DI和数据域NUMBERS开始的地址的差赋给DX，则DL便是所要求的还需要输入的数字个数，接下来对DL的值进行分析，如果DL==10，则直接调用已经写好的数据域AUX输出10，否则DL加030H并利用INT 21H的AH=02H模式输出字符，在此前后，程序显示一些交互的信息，具体方式可见Line138之后的具体实现，主要方式是调用INT 21H的AH=09H的中断，具体叙述略去

下面简述SHOW函数的具体实现，首先仍然使用INT 21H的AH=09H中断进行一些用户交互信息的输出，之后程序将SI置为NUMBERS区尾地址，并逐字节读取直到DI==SI，在每次读取到DL后，拷贝到DH，其中DH去低4位，DL取高4位，分别移到相对应的低4位补加030H转ASCII码，先高位DL后低位DH调用INT 21H的AH=02H输出字符，之后程序依然完成一些用户交互上而定输出。其中具体实现见Line160

下面简述循环中最后一个模块OUTPUT的实现，首先将DH中的值移到DI所指示的内存中，递减DI，清空DH，等待下次输入，具体实现在Line78

至此，程序完成输入部分的操作

在Line84，程序开始调用WHOLE函数逐个显示输入的数值，WHOLE显示一个BX中信息，因此首先这里显示MESSAGE中的用户交互信息，WHOLE的具体实现在Line185，具体的方式和之前提到的SHOW大同小异，这里就不进行进一步的叙述了，唯一的不同是，输出的间隔从空格改变成为了换行符

在Line90程序开始执行冒泡排序，具体算法如下

首先程序将DL标志置零，在遍历中一旦发现有前面的字符大于后面的字符的情况，DL变为1，程序在Line101退出直到DL为0，说明整个数组已经从小到大排序，在遍历中，程序执行如下操作

内层循环开始时，程序将DI指向NUMBERS开始地址，并读取两位到AX，其中AL是前一位，AH是后一位，一旦AL大于AH，则将AL和AH交换顺序，重新将AX写入原位置，完成了检查和交换，之后DI递增，对于10个数的数组，程序执行9次。具体在Line94附近实现

在完成了冒泡排序后，数组从前到后是从小到大的排列，再次调用WHOLE函数，从后向前输出数组中的元素，完成排序

同时，直接输出数组的最后的一个元素，完成最大数的输出工作

至此，程序完成要求的所有工作，当然在上面执行的过程中，存在着一些利用INT 21H，主要是AH=09H的输出用户交互的工作

程序在Line131行将通过INT 21H，AH=04CH将控制权转回系统，并返回AL=0，之前所述的操作在前面几行进行

程序的代码如下所示，运行时的截图如图\ref{1},\ref{2}所示\\


\input{prog.asm}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{1.png}
\caption{输入过程（目前输入9个数字）}
\label{1}
\includegraphics[width=\textwidth]{2.png}
\caption{输出和排序过程}
\label{2}
\end{figure}
\section{思考题}
\begin{enumerate}
\item 若处理的是十六进制无符号数，程序应如何修改?

在字符存取的部分修改即可，加上判断，若字符为0到9，代码不变，存取时分别加减30H；若字符为
A到F，存取时加减37H。
\item 若处理的是带符号数，程序又应作何修改?

首先需要判断“-” 符号，然后根据正负号决定是否将两位数取补码后存储。取数时根据最高位判断正
负，决定输出到显示屏时是否要加上符号，客观的说，处理带符号数的难度要上升很多
\end{enumerate}
\section{完成情况}
本次实验因为准备充分，代码的调试已经事先完成，因此效果较好，在本次实验中，我理解了条件转移职能进行近地址跳转而不能进行远地址跳转并且使用函数解决了问题。同时，在使用函数的过程中，尽可能的避免了栈上空间的操作（程序中没有栈上空间的操作，所有的操作除了对数据块的读取外均在寄存器上进行），从最大程度上节约了运行时间，尽管，设计合适的压栈和函数可以进一步增加代码的可读性，但是作为低级语言，相对语言本身更在意的就是程序的执行效率，因此为了提高运行效率，可读性的牺牲也是可以理解的，虽然作为题目中的数据规模，避免内存访问所带来的运行时间减少是微乎其微的，但是作为对编程能力的锻炼仍然有着很大的意义
\end{document}